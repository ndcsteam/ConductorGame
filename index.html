<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micro:bit 準星控制器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
    tailwind.config = {
        darkMode: 'class',
        theme: {
            extend: {
                colors: {
                    primary: '#5D5CDE',
                },
            },
        },
    }
    </script>
    <style>
        .gameplay-area {
            position: relative;
            overflow: hidden;
            background-image: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.3) 100%);
            border: 2px solid #444;
        }
        
        .crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            pointer-events: none;
            transition: transform 0.1s ease-out;
        }
        
        .crosshair::before, .crosshair::after {
            content: "";
            position: absolute;
            background-color: red;
        }
        
        .crosshair::before {
            width: 2px;
            height: 40px;
            left: 19px;
            top: 0;
        }
        
        .crosshair::after {
            width: 40px;
            height: 2px;
            left: 0;
            top: 19px;
        }
        
        .crosshair-center {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: red;
            left: 17px;
            top: 17px;
        }
        
        .target {
            position: absolute;
            width: 30px;
            height: 30px;
            margin-left: -15px;
            margin-top: -15px;
            border-radius: 50%;
            border: 2px solid #ffcc00;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .target::after {
            content: "";
            width: 10px;
            height: 10px;
            background-color: #ffcc00;
            border-radius: 50%;
        }
        
        .target.hit {
            border-color: #00cc00;
            animation: pulse 0.5s infinite alternate;
        }
        
        .target.hit::after {
            background-color: #00cc00;
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        
        .dark .gameplay-area {
            background-image: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(255,255,255,0.1) 100%);
            border-color: #666;
        }

        .control-panel {
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .dark .control-panel {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        .sensitivity-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6 text-center text-primary">Micro:bit 準星控制器</h1>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-2">
                <div id="gameplayArea" class="gameplay-area bg-gray-100 dark:bg-gray-800 rounded-lg shadow-lg h-[60vh] md:h-[70vh]">
                    <div id="crosshair" class="crosshair">
                        <div class="crosshair-center"></div>
                    </div>
                    <div id="target" class="target"></div>
                </div>
                
                <div class="mt-4 grid grid-cols-2 gap-4">
                    <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 shadow-md">
                        <h3 class="font-semibold mb-2">控制方式</h3>
                        <p class="text-sm">傾斜 micro:bit 來移動準星。靠近目標時會變綠色。</p>
                        <div class="mt-2">
                            <button id="spawnTargetBtn" class="bg-primary hover:bg-opacity-90 text-white py-1 px-4 rounded">
                                重置目標
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 shadow-md">
                        <h3 class="font-semibold mb-2">命中計數</h3>
                        <div class="flex justify-between items-center">
                            <span>目標: <span id="targetCount">0</span></span>
                            <span>命中: <span id="hitCount">0</span></span>
                        </div>
                        <div class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                            停留在目標上超過1秒視為命中
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 shadow-md">
                <h2 class="text-xl font-semibold mb-4">連接與設定</h2>
                
                <div class="mb-4">
                    <button id="connectBtn" class="w-full bg-primary hover:bg-opacity-90 text-white font-medium py-2 px-4 rounded-md transition">
                        連接 Micro:bit
                    </button>
                </div>
                
                <div id="statusContainer" class="mb-4 p-3 bg-gray-200 dark:bg-gray-700 rounded-md">
                    <p id="statusText">尚未連接</p>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <label for="sensitivityX" class="block mb-1 font-medium">X軸靈敏度:</label>
                        <input type="range" id="sensitivityX" min="1" max="10" value="5" class="w-full h-2 bg-gray-300 dark:bg-gray-600 rounded-md appearance-none sensitivity-slider">
                        <div class="flex justify-between text-xs mt-1">
                            <span>低</span>
                            <span>高</span>
                        </div>
                    </div>
                    
                    <div>
                        <label for="sensitivityY" class="block mb-1 font-medium">Y軸靈敏度:</label>
                        <input type="range" id="sensitivityY" min="1" max="10" value="5" class="w-full h-2 bg-gray-300 dark:bg-gray-600 rounded-md appearance-none sensitivity-slider">
                        <div class="flex justify-between text-xs mt-1">
                            <span>低</span>
                            <span>高</span>
                        </div>
                    </div>
                    
                    <div>
                        <label for="deadzone" class="block mb-1 font-medium">死區大小:</label>
                        <input type="range" id="deadzone" min="0" max="500" value="100" class="w-full h-2 bg-gray-300 dark:bg-gray-600 rounded-md appearance-none sensitivity-slider">
                        <div class="flex justify-between text-xs mt-1">
                            <span>小</span>
                            <span>大</span>
                        </div>
                    </div>
                    
                    <div>
                        <button id="calibrateBtn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-md transition disabled:opacity-50">
                            校準水平位置
                        </button>
                    </div>
                </div>
                
                <div class="mt-6">
                    <h3 class="font-semibold mb-2">座標數據</h3>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-gray-200 dark:bg-gray-700 rounded p-2">
                            <div class="text-red-500 font-bold">X</div>
                            <div id="xValue" class="font-mono">0</div>
                        </div>
                        <div class="bg-gray-200 dark:bg-gray-700 rounded p-2">
                            <div class="text-green-500 font-bold">Y</div>
                            <div id="yValue" class="font-mono">0</div>
                        </div>
                        <div class="bg-gray-200 dark:bg-gray-700 rounded p-2">
                            <div class="text-blue-500 font-bold">Z</div>
                            <div id="zValue" class="font-mono">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="mt-6 bg-yellow-100 dark:bg-yellow-900 p-4 rounded-lg text-yellow-800 dark:text-yellow-200">
            <h3 class="font-bold text-lg mb-2">Micro:bit 設定指南</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <h4 class="font-semibold mb-1">發送端 Micro:bit:</h4>
                    <div class="mt-2 p-2 bg-white dark:bg-gray-950 rounded text-xs font-mono overflow-auto">
                        radio.setGroup(1)<br>
                        basic.forever(function() {<br>
                        &nbsp;&nbsp;let x = input.acceleration(Dimension.X)<br>
                        &nbsp;&nbsp;let y = input.acceleration(Dimension.Y)<br>
                        &nbsp;&nbsp;let z = input.acceleration(Dimension.Z)<br>
                        &nbsp;&nbsp;let data = "X:" + x + ",Y:" + y + ",Z:" + z<br>
                        &nbsp;&nbsp;radio.sendString(data)<br>
                        &nbsp;&nbsp;basic.pause(50) // 高頻率更新<br>
                        })
                    </div>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">接收端 Micro:bit:</h4>
                    <div class="mt-2 p-2 bg-white dark:bg-gray-950 rounded text-xs font-mono overflow-auto">
                        radio.setGroup(1)<br>
                        basic.showIcon(IconNames.Target)<br>
                        radio.onReceivedString(function(data) {<br>
                        &nbsp;&nbsp;serial.writeLine(data)<br>
                        &nbsp;&nbsp;led.toggle(4, 0)<br>
                        })
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 檢測暗色模式
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // 全域變數
        let port = null;
        let reader = null;
        let readLoop = false;
        let lastDataTime = 0;
        
        // 校準與控制相關
        let calibrationX = 0;
        let calibrationY = 0;
        let calibrationZ = 0;
        let isCalibrated = false;
        
        // 遊戲相關
        let targetCount = 0;
        let hitCount = 0;
        let isHitting = false;
        let hitTimer = null;
        
        // DOM 元素
        const connectBtn = document.getElementById('connectBtn');
        const statusText = document.getElementById('statusText');
        const xValue = document.getElementById('xValue');
        const yValue = document.getElementById('yValue');
        const zValue = document.getElementById('zValue');
        const crosshair = document.getElementById('crosshair');
        const target = document.getElementById('target');
        const gameplayArea = document.getElementById('gameplayArea');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const sensitivityX = document.getElementById('sensitivityX');
        const sensitivityY = document.getElementById('sensitivityY');
        const deadzone = document.getElementById('deadzone');
        const spawnTargetBtn = document.getElementById('spawnTargetBtn');
        const targetCountEl = document.getElementById('targetCount');
        const hitCountEl = document.getElementById('hitCount');

        // 連接到 Micro:bit
        connectBtn.addEventListener('click', async () => {
            if (port) {
                await disconnectFromDevice();
                return;
            }

            try {
                statusText.textContent = '請選擇接收端 micro:bit 裝置...';
                
                // 檢查瀏覽器支援
                if (!navigator.serial) {
                    throw new Error('您的瀏覽器不支援 Web Serial API。請使用 Chrome、Edge 或其他支援的瀏覽器。');
                }
                
                // 請求序列埠
                port = await navigator.serial.requestPort();
                
                statusText.textContent = '連接中...';
                
                // 開啟序列埠 (波特率設為 115200)
                await port.open({ baudRate: 115200 });
                
                // 設置讀取器
                const decoder = new TextDecoder();
                reader = port.readable.getReader();
                readLoop = true;
                
                statusText.textContent = '已連接 - 等待數據中';
                connectBtn.textContent = '中斷連接';
                calibrateBtn.disabled = false;
                
                // 開始讀取數據
                let buffer = '';
                
                while (readLoop) {
                    const { value, done } = await reader.read();
                    if (done) {
                        break;
                    }
                    
                    // 將收到的數據添加到緩衝區
                    buffer += decoder.decode(value);
                    
                    // 處理完整行
                    let newlineIndex;
                    while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                        const line = buffer.substring(0, newlineIndex).trim();
                        buffer = buffer.substring(newlineIndex + 1);
                        
                        if (line) {
                            processSerialData(line);
                        }
                    }
                }
                
            } catch (error) {
                console.error('連接錯誤:', error);
                statusText.textContent = `錯誤: ${error.message}`;
                await disconnectFromDevice();
            }
        });

        // 處理序列數據
        function processSerialData(line) {
            try {
                // 記錄接收時間
                const now = new Date();
                lastDataTime = now.getTime();
                
                // 處理數據 - 支援兩種格式:
                let x = 0, y = 0, z = 0;
                let dataProcessed = false;
                
                // 嘗試解析 JSON 格式 {"x":123,"y":456,"z":789}
                if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                    try {
                        const data = JSON.parse(line);
                        if ('x' in data && 'y' in data && 'z' in data) {
                            x = data.x;
                            y = data.y;
                            z = data.z;
                            dataProcessed = true;
                        }
                    } catch (jsonError) {
                        // 繼續嘗試其他格式
                    }
                }
                
                // 嘗試解析簡單格式 X:123,Y:456,Z:789
                if (!dataProcessed && line.includes('X:') && line.includes('Y:') && line.includes('Z:')) {
                    try {
                        // 提取 X 值
                        const xMatch = line.match(/X:(-?\d+)/);
                        if (xMatch && xMatch[1]) {
                            x = parseInt(xMatch[1], 10);
                        }
                        
                        // 提取 Y 值
                        const yMatch = line.match(/Y:(-?\d+)/);
                        if (yMatch && yMatch[1]) {
                            y = parseInt(yMatch[1], 10);
                        }
                        
                        // 提取 Z 值
                        const zMatch = line.match(/Z:(-?\d+)/);
                        if (zMatch && zMatch[1]) {
                            z = parseInt(zMatch[1], 10);
                        }
                        
                        dataProcessed = true;
                    } catch (parseError) {
                        // 繼續嘗試其他格式
                    }
                }
                
                // 如果成功處理了數據
                if (dataProcessed) {
                    // 更新數據顯示
                    updateDataDisplay(x, y, z);
                    
                    // 更新準星位置
                    updateCrosshairPosition(x, y, z);
                    
                    // 檢查是否命中目標
                    checkTargetHit();
                    
                    statusText.textContent = `接收中 - 上次更新: ${now.toLocaleTimeString()}`;
                }
                
            } catch (e) {
                console.error('處理數據錯誤:', e);
            }
        }

        // 更新數據顯示
        function updateDataDisplay(x, y, z) {
            xValue.textContent = x;
            yValue.textContent = y;
            zValue.textContent = z;
        }

        // 更新準星位置
        function updateCrosshairPosition(x, y, z) {
            // 如果尚未校準，不更新位置
            if (!isCalibrated && !calibrationX && !calibrationY) {
                return;
            }
            
            // 計算相對於校準位置的偏移
            let deltaX = x - calibrationX;
            let deltaY = y - calibrationY;
            
            // 套用死區
            const deadzoneValue = parseInt(deadzone.value);
            if (Math.abs(deltaX) < deadzoneValue) deltaX = 0;
            if (Math.abs(deltaY) < deadzoneValue) deltaY = 0;
            
            // 套用靈敏度
            const sensX = parseFloat(sensitivityX.value) / 5;
            const sensY = parseFloat(sensitivityY.value) / 5;
            
            // 計算準星位置（反轉Y軸方向以匹配直覺）
            const areaRect = gameplayArea.getBoundingClientRect();
            const areaWidth = areaRect.width;
            const areaHeight = areaRect.height;
            
            // 將加速度計值映射到畫面座標
            // X軸校準值0對應畫面中心，向右傾斜增加值，向左減少值
            // 將X值限制在視窗範圍內
            let posX = (areaWidth / 2) + (deltaX * sensX);
            posX = Math.max(0, Math.min(areaWidth, posX));
            
            // Y軸校準值0對應畫面中心，向前傾斜增加值，向後減少值
            // 由於螢幕Y軸向下，我們需要反轉方向
            let posY = (areaHeight / 2) - (deltaY * sensY);
            posY = Math.max(0, Math.min(areaHeight, posY));
            
            // 更新準星位置
            crosshair.style.left = `${posX}px`;
            crosshair.style.top = `${posY}px`;
        }

        // 校準按鈕事件
        calibrateBtn.addEventListener('click', function() {
            // 獲取當前數值作為校準基準
            calibrationX = parseInt(xValue.textContent) || 0;
            calibrationY = parseInt(yValue.textContent) || 0;
            calibrationZ = parseInt(zValue.textContent) || 0;
            isCalibrated = true;
            
            // 重置準星位置到中心
            const areaRect = gameplayArea.getBoundingClientRect();
            crosshair.style.left = `${areaRect.width / 2}px`;
            crosshair.style.top = `${areaRect.height / 2}px`;
            
            statusText.textContent = '已校準 - 當前位置設為中心點';
            calibrateBtn.textContent = '重新校準';
            
            // 產生一個新目標
            spawnTarget();
        });

        // 產生目標
        function spawnTarget() {
            const areaRect = gameplayArea.getBoundingClientRect();
            
            // 產生隨機位置，但避開邊緣
            const margin = 50;
            const randomX = Math.random() * (areaRect.width - 2 * margin) + margin;
            const randomY = Math.random() * (areaRect.height - 2 * margin) + margin;
            
            // 設定目標位置
            target.style.left = `${randomX}px`;
            target.style.top = `${randomY}px`;
            target.classList.remove('hit');
            
            // 增加目標計數
            targetCount++;
            targetCountEl.textContent = targetCount;
        }

        // 檢查是否命中目標
        function checkTargetHit() {
            // 獲取準星和目標的位置
            const crosshairRect = crosshair.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();
            
            // 計算準星和目標的中心點
            const crosshairCenterX = crosshairRect.left + crosshairRect.width / 2;
            const crosshairCenterY = crosshairRect.top + crosshairRect.height / 2;
            const targetCenterX = targetRect.left + targetRect.width / 2;
            const targetCenterY = targetRect.top + targetRect.height / 2;
            
            // 計算距離
            const distance = Math.sqrt(
                Math.pow(crosshairCenterX - targetCenterX, 2) + 
                Math.pow(crosshairCenterY - targetCenterY, 2)
            );
            
            // 如果距離小於目標半徑，表示命中
            if (distance < targetRect.width) {
                // 如果尚未處於命中狀態，開始計時
                if (!isHitting) {
                    isHitting = true;
                    target.classList.add('hit');
                    
                    // 一秒後計為有效命中
                    hitTimer = setTimeout(() => {
                        hitCount++;
                        hitCountEl.textContent = hitCount;
                        spawnTarget();
                    }, 1000);
                }
            } else {
                // 如果離開目標，重置命中狀態
                if (isHitting) {
                    isHitting = false;
                    target.classList.remove('hit');
                    clearTimeout(hitTimer);
                }
            }
        }

        // 重置目標按鈕
        spawnTargetBtn.addEventListener('click', function() {
            spawnTarget();
        });

        // 中斷裝置連接
        async function disconnectFromDevice() {
            if (reader) {
                readLoop = false;
                try {
                    await reader.cancel();
                    reader.releaseLock();
                } catch (e) {
                    console.log('停止讀取時發生錯誤:', e);
                }
                reader = null;
            }
            
            if (port) {
                try {
                    await port.close();
                } catch (e) {
                    console.log('關閉連接時發生錯誤:', e);
                }
                port = null;
            }
            
            statusText.textContent = '已中斷連接';
            connectBtn.textContent = '連接 Micro:bit';
            calibrateBtn.disabled = true;
        }

        // 初始化目標位置
        function initializeGame() {
            // 設置初始目標位置在中心
            const areaRect = gameplayArea.getBoundingClientRect();
            target.style.left = `${areaRect.width / 2}px`;
            target.style.top = `${areaRect.height / 2}px`;
            
            // 設置初始準星位置在中心
            crosshair.style.left = `${areaRect.width / 2}px`;
            crosshair.style.top = `${areaRect.height / 2}px`;
            
            // 禁用校準按鈕，直到連接
            calibrateBtn.disabled = true;
        }

        // 當頁面加載或調整大小時初始化
        window.addEventListener('load', initializeGame);
        window.addEventListener('resize', initializeGame);

        // 檢測信號丟失
        setInterval(() => {
            if (port && lastDataTime > 0) {
                const now = new Date().getTime();
                const timeSinceLastData = now - lastDataTime;
                
                // 如果超過3秒未收到數據
                if (timeSinceLastData > 3000) {
                    statusText.textContent = `警告: ${Math.floor(timeSinceLastData/1000)}秒未收到數據`;
                    statusText.classList.add('text-red-500');
                } else {
                    statusText.classList.remove('text-red-500');
                }
            }
        }, 1000);
    </script>
</body>
</html>
